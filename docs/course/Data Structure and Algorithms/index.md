# 数据结构与算法
## 绪论
图灵机模型

RAM模型：

算法的**运行时间** $\propto$ 算法需要执行的基本**操作次数**

时间成本 ~ 各条指令执行次数之总和

渐进复杂度：大O几号

其他记号：大omiga，大sita几号

复杂度：

- $O(1)$: constant 最好情况
- $O(log^{c}n)$: poly-log 复杂度无限接近于常数
- $O(c^{c})$: polynomial
- $O(2^{n})$: exponential
算法分析：

两个主要任务 = 正确性（不变性×单调性）+ 复杂度

- 算数级数：与末项平方同阶
- 幂方级数：比幂次高出一阶  
- 几何级数：与末项同阶
- 收敛级数：O(1)
- 调和级数：O(log n)
- 对数级数： $\sum_{i=1}^{n} lnk$ = O(nlogn)

迭代和递归：减而治之

动态规划：

$10^{9}flo = 1sec$


## 第二章 向量

- 抽象数据类型=数据模型+定义在该模型上的一组操作
- 数据结构=基于某种特定语言，实现抽象数据类型的一整套算法

数组：寻秩访问

向量是数组的抽象与泛化，由一组元素按线性次序**封装**而成
各元素与[0,n)内的**秩(rank)**一一对应  using Rank=unsigned int;

向量ADT接口：

- size()
- get( r )
- put(r,e)
- insert(r,e)
- remove(r)
- disordered()
- sort()
- find(e)
- search(e) 相同的返回最后面一个
- uniquify() 
-

## 重点

### 向量扩容

如果采用固定容量，可能导致上溢。所以我们采用动态变化的长度。

如果每次达到上界都采用固定增量，每次扩容中复制原向量的时间成本为：

$$ 0,I,2I,3I,4I,...,(m-1)I $$

总时间复杂度为$O(n^{2})$，装填因子约等于100%

如果采用倍增增量，每次扩容中复制原向量的时间成本为：

$$ 1,2,4,8,16,...,2^{m-1},2^{m}=n $$

总时间复杂度为$O(n)$，装填因子只能保证＞50%

### 二分查找

- 版本A

    - mi=(lo+hi)>>1;
    - if (x > e) 递归[lo,mi)
    - else if (x < e) 递归(mi,hi)
    - else 命中，返回

    由于向左走只需要比较一次，向右走需要比较两次，所以朝两边走比较次数不等。故得到改进措施：左边占据的比例为：
    $$ \lambda =\frac{\sqrt{5} - 1 }{2} $$

- 版本B

    - mi=(lo+hi)>>1;
    - if (x>e) 递归[lo,mi)
    - else 递归[mi,hi)
    - 直到hi-lo==1 停止

- 版本C

    尝试约定：search(e)返回的是不大于e的最后一个元素的秩
    
    解决方法：e < S[mi] ? hi = mi : lo = mi + 1;

    这种方法重新进行了语义规定：在算法执行过程中的任意时刻，A[lo-1] 总是（截至当前已确认的）不大于e的最大者(m)，A[hi] 总是（截至当前已确认的）大于e的最小者（M）








## 题库答案

重点：6，9，10，12，14，20，25，27，33，37，



1. C (尽管有程序，但是程序不等于算法。该问题目前还没有结论。)

2. D（易错，答案是效率，而不是正确）

3. A（图灵机组件：无限长纸带、有限字母表、读写头、有限种状态）

4. B（RAM为random access machine，拥有无限存储，而图灵机也有无限存储。它们区别在于可以RAM可以通过编号直接访问任意位置元素）

5. B

6. B (C选项可以使用斯特林公式)

7. B （一个平凡；另一个规模更小即可，不要求平凡）

8. B（都是O(n)

9. B(复杂度为$\theta (1+2+4+……+2^{n-2})=\theta (2^{n-1})=O(2^{n})$)

10. D

11. D(递推，空间只需要两个变量)

12. C

13. C(注意下标从0开始，且insert时如果当前位置有元素了，需要把它也后移)

14. B

15. A(hi是最后一个元素的后一个位置，lo是第一个元素的位置)

16. B（总时间复杂度$O(n^{2})$，分摊时间复杂度$O(n)$）

17. A 

18. C（没有大小区分）

19. B

20. B

21. A

22. C

23. A

24. BD都可以吗？

25. A(hi是最后一个元素后一个，lo是第一个元素)

26. C

27. B   

28. A

29. C（D呢？）

30. 

31. C (插值查找 = 在字长意义上的折半查找，二分查找 = 在字长意义上的顺序查找)

32. 5

34. A

35. D

36. C

37. B

38. A

39. A

40. B（归并排序的最优、最坏、平均时间复杂度都是nlogn）

41.   

42. C（C选项，分别为-1,0,n-1,n）

43. C

44. D

45. A（反复判断相邻两个是否相等，如果相等就直接删除后者）

46. C

47. C（每次选最大的，所以是降序）

48. A（采用比较器!lt()或ge()，从而等效于后者优先）

49. C

50. C

51. B（最好是O(n)，因为search是从后往前search，所以如果已经有序的话每次search都只要一次）

52. C（在时刻k始终保证前k个有序且元素不变，后k个无序且元素不变，A是选择排序）

53. C（每次迭代多一个元素有序）

54. B（向量慢，因为不能二分）

55. B（这种题模拟即可）

56. B（无法随机访问，只能顺序查找）

57. C（每次找最大的）

58. A（最小的移到前面选最前面的，最大的移到后面选最后面的）

59. C（同52）

60. B（插入排序保证前r个元素不变且有序）

61. 

62. B（O(k+2k+3k+……+n)=O((n+k)k/2)=O(nk)）

63. C（模拟）

64. B（左括号进栈，右括号出栈）

65. B（312型不是栈混洗，或直接模拟）

66. 14（长度为n的序列的栈混洗数为第n个卡特兰数，$C_{4}$=14）

67. D（两个栈，遇到操作数压入操作数栈，遇到操作符如果比操作符栈顶高就压入操作符栈，否则弹出两个操作数进行运算再压入操作数栈，最后处理剩余）

68. B（逆波兰：后缀；波兰：前缀。后缀遇到操作符就弹出两个数）

69. B（画树）

70. A（模拟）

71. A（短除法）

72. D（模拟）

73. C（312型不是）

74. B（卡特兰数问题：网格计数、01序列、栈混洗（312排列）、不相交弦问题、二叉树总数；卡特兰数通项$h(n)= \frac{1}{n+1} \binom{2n}{n}$）

75. C（左括号小于一切，右括号大于一切）

76. X+1X2!3-X457

77.





77. D

78. C




157. B

160. 

161. 190 19

162. 7

163. A

164. D

169. 对

170. 对

171. D

172. A

173.

174. B

175. 

176. B

177. B（C存疑）

178. B（存疑）

179. 正确

181. 

182. A

183. C

184. C

185. C

186. A

188. A

198. B

211. EACBD

212. B

213.

200. C

201. 