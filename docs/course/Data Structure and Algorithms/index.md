# 数据结构与算法
## 绪论
图灵机模型

RAM模型：

算法的**运行时间** $\propto$ 算法需要执行的基本**操作次数**

时间成本 ~ 各条指令执行次数之总和

渐进复杂度：大O几号

其他记号：大omiga，大sita几号

复杂度：

- $O(1)$: constant 最好情况
- $O(log^{c}n)$: poly-log 复杂度无限接近于常数
- $O(c^{c})$: polynomial
- $O(2^{n})$: exponential
算法分析：

两个主要任务 = 正确性（不变性×单调性）+ 复杂度

- 算数级数：与末项平方同阶
- 幂方级数：比幂次高出一阶  
- 几何级数：与末项同阶
- 收敛级数：O(1)
- 调和级数：O(log n)
- 对数级数： $\sum_{i=1}^{n} lnk$ = O(nlogn)

迭代和递归：减而治之

动态规划：

$10^{9}flo = 1sec$


## 第二章 向量

- 抽象数据类型=数据模型+定义在该模型上的一组操作
- 数据结构=基于某种特定语言，实现抽象数据类型的一整套算法

数组：寻秩访问

向量是数组的抽象与泛化，由一组元素按线性次序**封装**而成
各元素与[0,n)内的**秩(rank)**一一对应  using Rank=unsigned int;

向量ADT接口：

- size()
- get( r )
- put(r,e)
- insert(r,e)
- remove(r)
- disordered()
- sort()
- find(e)
- search(e) 相同的返回最后面一个
- uniquify() 
-

## 重点

### 向量扩容

如果采用固定容量，可能导致上溢。所以我们采用动态变化的长度。

如果每次达到上界都采用固定增量，每次扩容中复制原向量的时间成本为：

$$ 0,I,2I,3I,4I,...,(m-1)I $$

总时间复杂度为$O(n^{2})$，装填因子约等于100%

如果采用倍增增量，每次扩容中复制原向量的时间成本为：

$$ 1,2,4,8,16,...,2^{m-1},2^{m}=n $$

总时间复杂度为$O(n)$，装填因子只能保证＞50%

### 二分查找

- 版本A

    - mi=(lo+hi)>>1;
    - if (x > e) 递归[lo,mi)
    - else if (x < e) 递归(mi,hi)
    - else 命中，返回

    由于向左走只需要比较一次，向右走需要比较两次，所以朝两边走比较次数不等。故得到改进措施：左边占据的比例为：
    $$ \lambda =\frac{\sqrt{5} - 1 }{2} $$

- 版本B

    - mi=(lo+hi)>>1;
    - if (x>e) 递归[lo,mi)
    - else 递归[mi,hi)
    - 直到hi-lo==1 停止

- 版本C

    尝试约定：search(e)返回的是不大于e的最后一个元素的秩
    
    解决方法：e < S[mi] ? hi = mi : lo = mi + 1;

    这种方法重新进行了语义规定：在算法执行过程中的任意时刻，A[lo-1] 总是（截至当前已确认的）不大于e的最大者(m)，A[hi] 总是（截至当前已确认的）大于e的最小者（M）





## 考前重点

- fibsearch：每次选择mi时，mi-lo为fib-1,且mi达到最大

- 插值查找平均时间复杂度：O(loglogn)

- 插值排序时，解出来mi要向下取整

- 向量中search约定相同返回秩最大的

- 归并排序的最优、最坏、平均时间复杂度都是nlogn

- 如果一个列表的 visible list 部分长度为 n，则头、首、末、尾节点的秩分别为 -1, 0, n-1, n

- 列表的selectsort，在遇到相同的时候，选出最后一个的放到最后

- insertionsort最好O(n)，平均和最坏时$O(n^{2})$

- 向量归并排序时间复杂度为$O(nlog_{2}(n)),列表为O(n^{2})$

-

## 题库答案

重点：6，9，10，12，14，20，25，27，33，37，

易错问题：1，2，3，4，6，10，14，15，17,18，19，29,30

1. C (尽管有程序，但是程序不等于算法。该问题目前还没有结论。)

2. D（易错，答案是效率，而不是正确）

3. A（图灵机组件：无限长纸带、有限字母表、读写头、有限种状态）

4. B（RAM为random access machine，拥有无限存储，而图灵机也有无限存储。它们区别在于可以RAM可以通过编号直接访问任意位置元素）

5. B（定义）

6. D (C选项可以使用斯特林公式)

7. B （一个平凡；另一个规模更小即可，不要求平凡）

8. B（都是O(n)）

9. B(复杂度为$\theta (1+2+4+……+2^{n-2})=\theta (2^{n-1})=O(2^{n})$)

10. D（普通计算机的速度：）

11. D(递推，空间只需要两个变量)

12. C（A错在哪，）

13. C(注意下标从0开始，且insert时如果当前位置有元素了，需要把它也后移)

14. B（最后为71，装填因子为实际/总空间）

15. A(hi是最后一个元素的后一个位置，lo是第一个元素的位置，左闭右开)

16. B（总时间复杂度 $O(n^{2})$，分摊时间复杂度 $O(n)$）

17. A （内存翻倍总量 $O(1+2+...+2^{m-1})=O(2^{m})=O(n)）

18. C（没有大小关系）

19. B（定义）

20. B（算法定义）

21. A（uniquify：唯一化）

22. C（有序，所以一定紧邻）

23. A（哨位在-1）

24. D（search返回不大于的最后一个元素）

25. A(hi是最后一个元素后一个，lo是第一个元素)

26. C(右移的定义)

27. B（和7两次，然后和13两次，然后和17一次）

28. A（只和相对大小有关）

29. C（D选项渐进复杂度都是O(logn)）

30. D（每次选择mi时，mi-lo为fib-1,且mi达到最大）

31. C (插值查找 = 在字长意义上的折半查找，二分查找 = 在字长意义上的顺序查找)

32. 1（向下取整）

33. D（版本A可能一次就找到了，B和C都需要做到底）

34. A（search约定）

35. D（算法定义）

36. C（模拟）

37. B（有一次什么都没交换）

38. C（稳定不会改变上一次的排序结果）

39. A（模拟）

40. B（归并排序的最优、最坏、平均时间复杂度都是nlogn）

41. A（列表用指针实现）  

42. C（C选项，分别为-1,0,n-1,n）

43. C（模拟）

44. D（O(n/2)=O(n)）

45. A（反复判断相邻两个是否相等，如果相等就直接删除后者）

46. C（只能扫一遍）

47. C（每次选最大的，所以是降序）

48. A（采用比较器!lt()或ge()，从而等效于后者优先，选出最靠后的移到最右边）

49. C（最坏都是平方）

50. C（倒序）

51. B（最好是O(n)，因为search是从后往前search，所以如果已经有序的话每次search都只要一次）

52. C（在时刻k始终保证前k个有序且元素不变，后k个无序且元素不变，A是选择排序）

53. C（每次迭代多一个元素有序）

54. C（定义）

55. B（这种题模拟即可）

56. B（无法随机访问，只能顺序查找）

57. C（每次找最大的）

58. A（最小的移到前面选最前面的，最大的移到后面选最后面的）

59. C（同52）

60. B（插入排序保证前r个元素不变且有序）

61. （答案B）

62. B($O(k^{2}*\frac{n}{k})=O(nk)$)

63. C（模拟）

64. B（左括号进栈，右括号出栈）

65. B（312型不是栈混洗，或直接模拟）

66. 14（长度为n的序列的栈混洗数为第n个卡特兰数，$C_{4}$=14）

67. D（两个栈，遇到操作数压入操作数栈，遇到操作符如果比操作符栈顶高就压入操作符栈，否则弹出两个操作数进行运算再压入操作数栈，最后处理剩余）

68. B（逆波兰：后缀；波兰：前缀。后缀遇到操作符就弹出两个数）

69. B（画树）

70. A（模拟）

71. A（短除法）

72. D（模拟）

73. C（312型不是）

74. B（卡特兰数问题：网格计数、01序列、栈混洗（312排列）、不相交弦问题、二叉搜索树总数；卡特兰数通项$h(n)= \frac{1}{n+1} \binom{2n}{n}$）

75. C（左括号小于一切，右括号大于一切）

76. 123!x+45x7-/

77. C（不用有向）

78. A（高度不一定差1）

79. B（O(3n)=O(n)）

80. D（真二叉树：所有度数要么0要么2）

81. B

82. C

83. （答案D）

84. C（模拟）

85. D（模拟）

86. C（层次遍历概念）

87. B（左节点）

88. B（层次遍历每层依次扩展）

89. A（后序遍历概念）

90. D（C添加节点就不会）

91. D（深度从上往下，高度从下往上。根节点深度0，叶子结点高度0。空树高度-1。高度定义为子节点最大高度+1）

92. C（右子树为空时是祖先）

93. D（模拟）

94. C（模拟）

95. D（只有先后不能推中，两个节点的二叉树（左右节点互换）就是最简单的反例）

96. D（高度父子可能不相差1）

97. A（A最对，B也对）

98. B（定义）

99. C（链）

100. C（模拟）

101. B（插入操作的定义）

102. C（重点，细看。先交换再删除）

103. B（中序遍历不变）

104. C（插入节点，从祖父开始往上，所有祖先都有可能失衡，O(logn)）

105. A（删除节点，从父亲开始往上，所有祖先都有可能失衡，但是只可能失衡一个，O(1)）

106. （答案B）A（既然已经失衡了，那么调整后就一定会减小1）

107. B（中序遍历不变）

108. D（旋转后原来最高的那个没变）

109. 14（卡特兰数）

110. 11（模拟）

111. D（模拟）

112. C（最坏单链）

113. B（保证中序遍历不变）

114. B（局部性：刚被访问过的数据，极有可能很快地再次被访问）

115. C（每次移到根）

116. B（每两层）

117. B（两层一半）

118. B（分摊复杂度logn）

119. A（zig-zag和zag-zig是一样的，关键在于子孙同侧的情况）

120. 错（依然有可能退化成链）

121. D（zag左旋，zig右旋）

122. A（局部性强、缓存命中率极高时，分摊每一次操作O(logk)）

123. 对（退化）

124. B（尽量矮胖）

125. A（每一层IO一次）

126. C（分支 $[\lceil \frac{m}{2} \rceil , m]$ ，元素 $[\lceil \frac{m}{2}-1 \rceil , m-1]$）

127. A（查找O(logn)，但这题问的是单个节点上的查找）

128. B（返回NULL代表失败）

129. B（相对于BBST，降低为 $\frac{1}{log_{2}m}-1$ ）

130. B（插入后超过最大可容纳）

131. C（为什么不是B？）

132. C（删除后小于 $\lceil \frac{m}{2} \rceil$ 了）

133. A（合并不是被旋转）

134. （答案错）

135. 错（说的是B数）

136. 错（伸展树无需记录高度或平衡因子，编程实现简单，优于AVL树）

137. 错（伸展树分摊复杂度O(logn)，与AVL树相当）

138. 对（伸展树会退化为链，AVL不会）

139. B（一次旋转）

140. A（中间节点选择 $\lfloor \frac{m}{2} \rfloor$，从0编号）

141. C（高度减半且1在根）

142. D（zigzig）

143. A(都余5)

144. B（必定冲突）

145. B（如果是单射就不满足不等式）

146. 3（0,8,4）；9（0,8,5,2,10,7,4,1,9）

147. B（A指针不在桶内部，B正确，C仍然存放在桶里，D存疑）

148. D（计算）

149. A（模拟）

150. （完全平方数mod一个素数，最多的可能取值有p/2向下取整+1（或者p/2上取整）种可能，答案0.5）

151. D（画图）

152. C（都要把所有的遍历一遍）

153. D（一列+一行）

154. D（概念）

155. A（模拟）

156. C（每个定点、每条边遍历一次）  

157. B（模拟）

158. B

159. C（都是n-1）   

160. B（有向图）

161. 190 19

162. 7

163. A

164. D

165. （答案B）

166. （答案C）

167. （答案2,65,7）

168. （答案3,14,7,12）

169. 对

170. 对

171. D（拓扑不唯一）

172. A（拓扑不唯一）

173. C（遍历一遍）

174. C（模拟）

175. 对（prim：染色）

176. B（单源最短路径）

177. B（无向图没有强联通）

178. B（算法定义）

179. 正确（算法定义）

180. 对（算法定义）

181. （答案A）

182. A

183. C

184. A（只能删最大的）

185. C

186. A

188. A

198. B

199. A

200. C

201. D


211. EACBD

212. B

213.

200. C

201. 